<!DOCTYPE html>
<html>
<head>
    <title>MiroTalk Basit Clone - WebRTC</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #videos { display: flex; flex-wrap: wrap; gap: 10px; }
        video { width: 320px; height: 240px; border: 1px solid #333; }
        .controls button { padding: 10px; margin: 5px; }
        .controls { margin-bottom: 20px; }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <h1>ðŸš€ Kendi WebRTC OdasÄ±</h1>
    
    <div class="controls">
        <input type="text" id="roomInput" placeholder="Oda AdÄ±">
        <button onclick="connectRoom()" id="joinButton">Odaya KatÄ±l</button>
        <button onclick="toggleVideo()" disabled id="videoButton">Video Kapat</button>
        <button onclick="toggleAudio()" disabled id="audioButton">Mikrofon Kapat</button>
        <button onclick="disconnect()" disabled id="disconnectButton" style="background-color: #dc3545;">Odadan AyrÄ±l</button>
    </div>

    <hr>
    
    <div id="videos">
        <div id="localVideoContainer">
            <h3>Siz (Local)</h3>
            <video id="localVideo" autoplay muted></video>
        </div>
    </div>

   <script>
// =======================================================
// Global DeÄŸiÅŸkenler ve Capacitor TanÄ±mlarÄ±
// =======================================================
const socket = io();
const localVideo = document.getElementById('localVideo');
const videosContainer = document.getElementById('videos');
const peers = {}; 
let localStream;

// KayÄ±t deÄŸiÅŸkenleri
let mediaRecorder;
let recordedChunks = []; 

// Capacitor API'lerini iÃ§eri aktarma (Ä°zin kontrolÃ¼ iÃ§in gerekli)
const { Plugins } = Capacitor;
const { Camera, App } = Plugins; 


// =======================================================
// 1. Ä°zin Kontrol Fonksiyonu (WebRTC'den Ã–nce Ã‡alÄ±ÅŸÄ±r)
// =======================================================

async function checkAndRequestPermissions() {
    // 1. Kamera izni durumunu kontrol et
    let cameraStatus = await Camera.checkPermissions();
    
    // Ä°zin verilmemiÅŸse, kullanÄ±cÄ±dan iste
    if (cameraStatus.camera !== 'granted') {
        let result = await Camera.requestPermissions();
        if (result.camera !== 'granted') {
            alert('Kamera izni verilmedi. Uygulama Ã§alÄ±ÅŸmayacaktÄ±r.');
            return false;
        }
    }
    
    // Not: Mikrofon izni genellikle kamera izni ile birlikte verilir.
    return true; // Ä°zinler baÅŸarÄ±lÄ±
}


// =======================================================
// 2. KayÄ±t FonksiyonlarÄ±
// =======================================================

// KaydÄ± BaÅŸlatma Fonksiyonu
function startRecording(stream) {
    if (!stream) return;
    
    const options = { mimeType: 'video/webm; codecs=vp8' }; 
    mediaRecorder = new MediaRecorder(stream, options);
    recordedChunks = []; 

    mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
            recordedChunks.push(event.data);
        }
    };

    // KayÄ±t durdurulduÄŸunda dosyayÄ± hazÄ±rlayÄ±p kaydetme
    mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        
        // Dosya adÄ± oluÅŸturma: TaylosCAM_YYYYMMDD_HHMMSS.webm
        const now = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const fileName = `TaylosCAM_${now}.webm`;

        // Dosya linki oluÅŸturma ve indirme (Telefonda "Ä°ndirilenler" klasÃ¶rÃ¼ne kaydeder)
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = fileName; 
        a.click(); 
        window.URL.revokeObjectURL(url);
        
        console.log("KayÄ±t dosyasÄ± indiriliyor:", fileName);
    };

    mediaRecorder.start(); 
    console.log("Video kaydÄ± baÅŸlatÄ±ldÄ±...");
}


// KaydÄ± Durdurma Fonksiyonu (Uygulama KapanÄ±nca Ã‡alÄ±ÅŸÄ±r)
function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        console.log("Video kaydÄ± durduruldu ve indirme baÅŸlatÄ±ldÄ±.");
    }
}


// =======================================================
// 3. WebRTC Ä°ÅŸlevleri ve Socket.IO
// =======================================================

async function connectRoom() {
    const roomID = document.getElementById('roomInput').value.trim();
    if (!roomID) {
        alert("LÃ¼tfen bir oda adÄ± girin.");
        return;
    }
    
    // Ä°zin KontrolÃ¼nÃ¼ Ekleme (APK Ä°zin Sorunu Ã‡Ã¶zÃ¼mÃ¼)
    const hasPermission = await checkAndRequestPermissions();
    if (!hasPermission) {
        return;
    }

    try {
        localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: { echoCancellation: true }
        });
        localVideo.srcObject = localStream;
        
        // KAYDI BAÅžLAT
        startRecording(localStream); 
        
        document.querySelectorAll('.controls button').forEach(btn => btn.disabled = false);
        document.getElementById('joinButton').disabled = true;

        socket.emit('joinRoom', roomID);

    } catch (err) {
        console.error("Medya eriÅŸim hatasÄ±:", err);
        alert("Kamera ve mikrofon eriÅŸimi reddedildi veya bulunamadÄ±.");
    }
}
    
function disconnect() {
    // KaydÄ± Durdurma ve Kaydetme (Uygulamadan Ã§Ä±kÄ±lÄ±rken)
    stopRecording(); 
    
    for (const id in peers) {
        peers[id].close();
    }
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    window.location.reload();
}

// Socket.IO OlaylarÄ± (DEÄžÄ°ÅžTÄ°RÄ°LMEDÄ°)
socket.on('userJoined', (peerID) => {
    const newPeer = createPeerConnection(peerID, true); 
    peers[peerID] = newPeer;
});

socket.on('userDisconnected', (peerID) => {
    if (peers[peerID]) {
        peers[peerID].close();
        delete peers[peerID];
    }
    const container = document.getElementById(`container-${peerID}`);
    if (container) {
        container.remove();
    }
});

socket.on('signal', async (data) => {
    if (!peers[data.senderID]) {
        peers[data.senderID] = createPeerConnection(data.senderID, false); 
    }

    const peerConnection = peers[data.senderID];
    const signal = data.signal;

    try {
        if (signal.type === 'offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('signal', { targetID: data.senderID, signal: peerConnection.localDescription });
        
        } else if (signal.type === 'answer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
        
        } else if (signal.candidate) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
        }
    } catch (err) {
        console.error("SinyalleÅŸme iÅŸleme hatasÄ±:", err);
    }
});

function createPeerConnection(peerID, isInitiator) {
    const peerConnection = new RTCPeerConnection({
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    });

    localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
    });

    peerConnection.onicecandidate = ({ candidate }) => {
        if (candidate) {
            socket.emit('signal', { targetID: peerID, signal: { candidate: candidate } });
        }
    };

    peerConnection.ontrack = (event) => {
        const remoteStream = event.streams[0];
        let remoteVideo = document.getElementById(`video-${peerID}`);

        if (!remoteVideo) {
            const container = document.createElement('div');
            container.id = `container-${peerID}`;
            container.innerHTML = `<h3>KullanÄ±cÄ± ${peerID.substring(0, 4)}...</h3>`;
            remoteVideo = document.createElement('video');
            remoteVideo.id = `video-${peerID}`;
            remoteVideo.autoplay = true;
            remoteVideo.srcObject = remoteStream;
            container.appendChild(remoteVideo);
            videosContainer.appendChild(container);
        } else {
            remoteVideo.srcObject = remoteStream;
        }
    };

    if (isInitiator) {
        peerConnection.onnegotiationneeded = async () => {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                socket.emit('signal', { targetID: peerID, signal: peerConnection.localDescription });
            } catch (err) {
                console.error("Teklif oluÅŸturma hatasÄ±:", err);
            }
        };
    }

    return peerConnection;
}

// Buton FonksiyonlarÄ± (DEÄžÄ°ÅžTÄ°RÄ°LMEDÄ°)
function toggleVideo() {
    const videoTrack = localStream.getVideoTracks()[0];
    if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        document.getElementById('videoButton').textContent = videoTrack.enabled ? 'Video Kapat' : 'Video AÃ§';
    }
}

function toggleAudio() {
    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        document.getElementById('audioButton').textContent = audioTrack.enabled ? 'Mikrofon Kapat' : 'Mikrofon AÃ§';
    }
}

// Global olarak eriÅŸilebilirliÄŸi koru
window.connectRoom = connectRoom;
window.toggleVideo = toggleVideo;
window.toggleAudio = toggleAudio;
window.disconnect = disconnect;

// Uygulama kapandÄ±ÄŸÄ±nda kaydÄ± otomatik durdur ve kaydet
window.addEventListener('beforeunload', stopRecording);
</script>
</body>
</html>
